<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/md5.js | aureooms/js-hash API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<script data-ice="userScript" src="user/script/0-header.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/aureooms/js-hash.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SHA512_Hasher.js~SHA512_Hasher.html">SHA512_Hasher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-md5">md5</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-md5fast">md5fast</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha1">sha1</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha224">sha224</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha256">sha256</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha384">sha384</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha512">sha512</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha512_call">sha512_call</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha512_cycle">sha512_cycle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha512_finalize">sha512_finalize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha512_initial_state">sha512_initial_state</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/md5.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { get32 , add32 , rotl32 , lil32 } from &apos;@aureooms/js-uint32&apos; ;

function cycle (h, k, r, w) {

	// initialize hash value for this chunk:
	let a = h[0];
	let b = h[1];
	let c = h[2];
	let d = h[3];

	// main loop
	for (let i = 0; i &lt; 64; ++i) {

		let f , g ;

		if (i &lt; 16) {
			f = (b &amp; c) | ((~ b) &amp; d);
			g = i;
		}
		else if (i &lt; 32) {
			f = (d &amp; b) | ((~ d) &amp; c);
			g = (5 * i + 1) % 16;
		}
		else if (i &lt; 48) {
			f = b ^ c ^ d;
			g = (3 * i + 5) % 16;
		}
		else {
			f = c ^ (b | (~ d));
			g = (7 * i) % 16;
		}

		const t = d;
		d = c;
		c = b;
		b = add32(b, rotl32(add32(add32(a, f), add32(k[i], w[g])) , r[i]));
		a = t;

	}

	// Add this chunk&apos;s hash to result so far:
	h[0] = add32(h[0], a);
	h[1] = add32(h[1], b);
	h[2] = add32(h[2], c);
	h[3] = add32(h[3], d);

}

function call (h, k, r, data, o) {

	//break chunk into sixteen 32-bit little-endian words w[i], 0 &#x2264; i &#x2264; 15

	const w = [
		lil32(data, o +  0),
		lil32(data, o +  4),
		lil32(data, o +  8),
		lil32(data, o + 12),
		lil32(data, o + 16),
		lil32(data, o + 20),
		lil32(data, o + 24),
		lil32(data, o + 28),
		lil32(data, o + 32),
		lil32(data, o + 36),
		lil32(data, o + 40),
		lil32(data, o + 44),
		lil32(data, o + 48),
		lil32(data, o + 52),
		lil32(data, o + 56),
		lil32(data, o + 60)
	];

	cycle(h, k, r, w);

}

/**
 * MD5
 */
export function md5 (bytes, n, digest) {

	const k = [
		get32(0xd76aa478), get32(0xe8c7b756), get32(0x242070db), get32(0xc1bdceee),
		get32(0xf57c0faf), get32(0x4787c62a), get32(0xa8304613), get32(0xfd469501),
		get32(0x698098d8), get32(0x8b44f7af), get32(0xffff5bb1), get32(0x895cd7be),
		get32(0x6b901122), get32(0xfd987193), get32(0xa679438e), get32(0x49b40821),
		get32(0xf61e2562), get32(0xc040b340), get32(0x265e5a51), get32(0xe9b6c7aa),
		get32(0xd62f105d), get32(0x02441453), get32(0xd8a1e681), get32(0xe7d3fbc8),
		get32(0x21e1cde6), get32(0xc33707d6), get32(0xf4d50d87), get32(0x455a14ed),
		get32(0xa9e3e905), get32(0xfcefa3f8), get32(0x676f02d9), get32(0x8d2a4c8a),
		get32(0xfffa3942), get32(0x8771f681), get32(0x6d9d6122), get32(0xfde5380c),
		get32(0xa4beea44), get32(0x4bdecfa9), get32(0xf6bb4b60), get32(0xbebfbc70),
		get32(0x289b7ec6), get32(0xeaa127fa), get32(0xd4ef3085), get32(0x04881d05),
		get32(0xd9d4d039), get32(0xe6db99e5), get32(0x1fa27cf8), get32(0xc4ac5665),
		get32(0xf4292244), get32(0x432aff97), get32(0xab9423a7), get32(0xfc93a039),
		get32(0x655b59c3), get32(0x8f0ccc92), get32(0xffeff47d), get32(0x85845dd1),
		get32(0x6fa87e4f), get32(0xfe2ce6e0), get32(0xa3014314), get32(0x4e0811a1),
		get32(0xf7537e82), get32(0xbd3af235), get32(0x2ad7d2bb), get32(0xeb86d391),
	] ;

	const r = [
		7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
		5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
		4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
		6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
	];

	// PREPARE

	const q = n / 8 | 0;
	const z = q * 8;
	const u = n - z;

	// append the bit &apos;1&apos; to the message
	let last ;
	if (u &gt; 0) {
		last = bytes[q] &amp; (~0) &lt;&lt; (7-u);
	}
	else {
		last = 0x80;
	}

	// initialize state
	const h = [
		get32(0x67452301),
		get32(0xefcdab89),
		get32(0x98badcfe),
		get32(0x10325476),
	] ;

	// Process the message in successive 512-bit chunks:
	// break message into 512-bit chunks

	const m = n / 512 | 0;
	const y = (n - 512 * m) / 8 | 0;

	// offset in data
	let o = 0;

	// for each chunk
	for (let j = 0; j &lt; m; ++j, o += 64) {
		call(h, k, r, bytes, o);
	}

	// last bytes + padding + length
	let tail = [];

	// last bytes
	for (let j = 0; j &lt; y; ++j) {
		tail.push(bytes[o + j]);
	}

	// special care taken for the very last byte which could
	// have been modified if n is not a multiple of 8
	tail.push(last);


	// append 0 &#x2264; k &lt; 512 bits &apos;0&apos;, so that the resulting
	// message length (in bits) is congruent to 448 (mod 512)
	let zeroes = (448 - (n + 1) % 512) / 8 | 0;

	if (zeroes &lt; 0) {
		// we need an additional block as there is
		// not enough space left to append
		// the length of the data in bits

		for (let j = 0; j &lt; -zeroes; ++j) {
			tail.push(0);
		}

		call(h, k, r, tail, 0);

		zeroes = 448 / 8;
		tail = [];
	}


	// pad with zeroes
	for (let j = 0; j &lt; zeroes; ++j) {
		tail.push(0);
	}

	// append length of message (before preparation), in bits,
	// as 64-bit little-endian integer

	tail.push((n &gt;&gt;&gt;  0) &amp; 0xFF);
	tail.push((n &gt;&gt;&gt;  8) &amp; 0xFF);
	tail.push((n &gt;&gt;&gt; 16) &amp; 0xFF);
	tail.push((n &gt;&gt;&gt; 24) &amp; 0xFF);
	// JavaScript works with 32 bit integers.
	// tail.push((n &gt;&gt;&gt; 32) &amp; 0xFF);
	// tail.push((n &gt;&gt;&gt; 40) &amp; 0xFF);
	// tail.push((n &gt;&gt;&gt; 48) &amp; 0xFF);
	// tail.push((n &gt;&gt;&gt; 56) &amp; 0xFF);
	tail.push(0);
	tail.push(0);
	tail.push(0);
	tail.push(0);

	call(h, k, r, tail, 0);

	digest[0]  = (h[0] &gt;&gt;&gt;  0) &amp; 0xFF;
	digest[1]  = (h[0] &gt;&gt;&gt;  8) &amp; 0xFF;
	digest[2]  = (h[0] &gt;&gt;&gt; 16) &amp; 0xFF;
	digest[3]  = (h[0] &gt;&gt;&gt; 24) &amp; 0xFF;
	digest[4]  = (h[1] &gt;&gt;&gt;  0) &amp; 0xFF;
	digest[5]  = (h[1] &gt;&gt;&gt;  8) &amp; 0xFF;
	digest[6]  = (h[1] &gt;&gt;&gt; 16) &amp; 0xFF;
	digest[7]  = (h[1] &gt;&gt;&gt; 24) &amp; 0xFF;
	digest[8]  = (h[2] &gt;&gt;&gt;  0) &amp; 0xFF;
	digest[9]  = (h[2] &gt;&gt;&gt;  8) &amp; 0xFF;
	digest[10] = (h[2] &gt;&gt;&gt; 16) &amp; 0xFF;
	digest[11] = (h[2] &gt;&gt;&gt; 24) &amp; 0xFF;
	digest[12] = (h[3] &gt;&gt;&gt;  0) &amp; 0xFF;
	digest[13] = (h[3] &gt;&gt;&gt;  8) &amp; 0xFF;
	digest[14] = (h[3] &gt;&gt;&gt; 16) &amp; 0xFF;
	digest[15] = (h[3] &gt;&gt;&gt; 24) &amp; 0xFF;

	return digest;

}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
